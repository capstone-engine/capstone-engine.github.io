<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Capstone - Diet engine</title><link rel="stylesheet" href="css/style.css" type="text/css" media="all"><link rel="stylesheet" href="css/pygments.css" type="text/css" media="all"><link rel="alternate" href="feed/index.xml" type="application/atom+xml" title="Atom Feed"></head><body><div id="fb-root"></div> <script>!function(e,t,n){var c,o=e.getElementsByTagName(t)[0];e.getElementById(n)||(c=e.createElement(t),c.id=n,c.src="//connect.facebook.net/en_US/all.js#xfbml=1",o.parentNode.insertBefore(c,o))}(document,"script","facebook-jssdk")</script><script>!function(t,e,r){var n,s=t.getElementsByTagName(e)[0],i=/^http:/.test(t.location)?"http":"https";t.getElementById(r)||(n=t.createElement(e),n.id=r,n.src=i+"://platform.twitter.com/widgets.js",s.parentNode.insertBefore(n,s))}(document,"script","twitter-wjs")</script><script>!function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="https://apis.google.com/js/plusone.js";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><div class="page"> <header> <a href="index.html" id="cs_home">Capstone</a> <nav> <a href="index.html">Home</a> <a href="download.html">Download</a> <a href="documentation.html">Docs</a> <a href="showcase.html">Showcase</a> <a href="testimonial.html">Testimonials</a> <a href="donate.html">Donate</a> <a href="contact.html">Contact</a> </nav> </header> <section><h2 id="building--programming-with-diet-engine">Building &amp; programming with “diet” engine</h2><p>This documentation introduces how to build Capstone for X86 architecture to minimize the libraries for embedding purpose.</p><p>Later part presents the APIs related to this feature and recommends the areas programmers should to pay attention to in their code.</p><h3 id="building-diet-engine">1. Building “diet” engine</h3><p>Typically, we use Capstone for usual applications, where the library weight does not really matter. Indeed, as of version <em>2.1-RC1</em>, the whole engine is only 1.9 MB including all architectures, and this size raises no issue to most people.</p><p>However, there are cases when we want to embed Capstone into special enviroments, such as OS kernel driver or firmware, where its size should be as small as possible due to space restriction. While we can always <a href="compile.html">compile only selected architectures</a> to make the libraries more compact, we still want to slim them down further.</p><p>Towards this object, since verson <em>2.1</em>, Capstone supports <em>diet</em> mode, in which some non-critical data are removed, thus making the engine size at least 40% smaller.</p><p>By default, Capstone is built in standard mode. To build <em>diet</em> engine, do: (demonstration is on *nix systems)</p><div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ CAPSTONE_DIET</span><span class="o">=</span>yes ./make.sh
<span class="nv">$ </span>sudo ./make.sh install</code></pre></div><p><br/> If we only <a href="compile.html">build selected architectures</a>, the engine is even smaller. Find below the size for each individual architecture compiled in <em>diet</em> mode.</p><table><thead><tr><th style="text-align:center">Architecture</th><th style="text-align:left">Library</th><th style="text-align:center">Standard binary</th><th style="text-align:center">“Diet” binary</th><th style="text-align:center">Reduced size</th></tr></thead><tbody><tr><td style="text-align:center">Arm</td><td style="text-align:left">libcapstone.a<br/>libcapstone.dylib</td><td style="text-align:center">730 KB<br/>599 KB</td><td style="text-align:center">603 KB<br/>491 KB</td><td style="text-align:center">18%<br/>19%</td></tr><tr><td style="text-align:center">Arm64</td><td style="text-align:left">libcapstone.a<br/>libcapstone.dylib</td><td style="text-align:center">519 KB<br/>398 KB</td><td style="text-align:center">386 KB<br/>273 KB</td><td style="text-align:center">26%<br/>32%</td></tr><tr><td style="text-align:center">Mips</td><td style="text-align:left">libcapstone.a<br/>libcapstone.dylib</td><td style="text-align:center">206 KB<br/>164 KB</td><td style="text-align:center">136 KB<br/>95 KB</td><td style="text-align:center">34%<br/>43%</td></tr><tr><td style="text-align:center">PowerPC</td><td style="text-align:left">libcapstone.a<br/>libcapstone.dylib</td><td style="text-align:center">140 KB<br/>103 KB</td><td style="text-align:center">69 KB<br/>50 KB</td><td style="text-align:center">51%<br/>52%</td></tr><tr><td style="text-align:center">X86</td><td style="text-align:left">libcapstone.a<br/>libcapstone.dylib</td><td style="text-align:center">809 KB<br/>728 KB</td><td style="text-align:center">486 KB<br/>452 KB</td><td style="text-align:center">40%<br/>38%</td></tr><tr><td style="text-align:center">Combine all 5 archs</td><td style="text-align:left">libcapstone.a<br/>libcapstone.dylib</td><td style="text-align:center">2.3 MB<br/>1.9 MB</td><td style="text-align:center">1.6 MB<br/>1.3 MB</td><td style="text-align:center">31%<br/>32%</td></tr></tbody></table><p><br/> (Above statistics were collected as of version <em>2.1-RC1</em>, built on Mac OSX 10.9.1 with clang-500.2.79)</p><h3 id="programming-with-diet-engine">2. Programming with “diet” engine</h3><h4 id="irrelevant-data-fields-with-diet-engine">2.1 Irrelevant data fields with “diet” engine</h4><p>To significantly reduce the engine size, some internal data has to be sacrificed. Specifically, the following data fields in <em>cs_insn</em> struct become irrelevant.</p><table><thead><tr><th style="text-align:left">Data field</th><th style="text-align:left">Meaning</th><th style="text-align:left">Replaced with</th></tr></thead><tbody><tr><td style="text-align:left">@mnemonic</td><td style="text-align:left">Mnemonic of instruction</td><td style="text-align:left">@id</td></tr><tr><td style="text-align:left">@op_str</td><td style="text-align:left">Operand string of instruction</td><td style="text-align:left">@detail-&gt;operands</td></tr><tr><td style="text-align:left">@detail-&gt;regs_read<br/>@detail-&gt;regs_read_count</td><td style="text-align:left">Registers implicitly read by instruction</td><td style="text-align:left">No</td></tr><tr><td style="text-align:left">@detail-&gt;regs_write<br/>@detail-&gt;regs_write_count</td><td style="text-align:left">Registers implicitly written by instruction</td><td style="text-align:left">No</td></tr><tr><td style="text-align:left">@detail-&gt;groups<br/>@detail-&gt;groups_count</td><td style="text-align:left">Semantic groups instruction belong to</td><td style="text-align:left">No</td></tr></tbody></table><p><br/> While these information is missing, fortunately we can still work out some critical information with the remaining data fields of <em>cs_insn</em> struct.</p><ul><li><p><strong>@mnemonic</strong></p><p>Without mnemonic information, we can rely on <em>@id</em> field of <em>cs_insn</em> struct.</p><p>For example, instruction “<em>ADD EAX, EBX</em>” would have @id as <em>X86_INS_ADD</em>.</p></li><li><p><strong>@op_str</strong></p><p>Without operand string, we can still extract equivalent information out of <em>@detail-&gt;operands</em>, which contains all details about operands of instruction.</p><p>For example, instruction “<em>ADD EAX, EBX</em>” would have 2 operands of register type <em>X86_OP_REG</em>, with register IDs of <em>X86_REG_EAX</em> &amp; <em>X86_REG_EBX</em>.</p></li></ul><p>Besides, all the details in architecture-dependent structures such as <em>cs_arm</em>, <em>cs_arm64</em>, <em>cs_mips</em>, <em>cs_ppc</em> &amp; <em>cs_x86</em> is still there for us to work out all the information needed, even without the missing fields.</p><h4 id="irrelevant-apis-with-diet-engine">2.2 Irrelevant APIs with “diet” engine</h4><p>While most Capstone APIs are still function exactly the same, due to these absent data fields, the following APIs become <em>irrelevant</em>.</p><ul><li><p><strong>cs_reg_name()</strong></p><p>Given a register ID (like X86_REG_EAX), we cannot retrieve its register name anymore.</p></li><li><p><strong>cs_insn_name()</strong></p><p>Given an instruction ID (like X86_INS_SUB), we cannot retrieve its instruction name anymore.</p></li><li><p><strong>cs_insn_group()</strong></p><p>We no longer have group information, so we cannot check if an instruction belongs to a particular group.</p></li><li><p><strong>cs_reg_read()</strong></p><p>We no longer have information about registers implicitly readed by instructions, so we cannot tell if an instruction read a particular register.</p></li><li><p><strong>cs_write_read()</strong></p><p>We no longer have information about registers implicitly readed by instructions, so we cannot tell if an instruction modify a particular register.</p></li></ul><p><br/> By <em>irrelevant</em>, we mean above APIs would return undefined value. Therefore, programmers have been warned <em>not to use these APIs</em> in <em>diet</em> mode.</p><h4 id="checking-engine-for-diet-status">2.3 Checking engine for “diet” status</h4><p>Capstone allows us to check if the engine was compiled in <em>diet</em> mode with <strong>cs_support()</strong> API, as followings - sample code in C.</p><div class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">if</span> <span class="p">(</span><span class="n">cs_support</span><span class="p">(</span><span class="n">CS_SUPPORT_DIET</span><span class="p">))</span> <span class="p">{</span>
	<span class="c1">// Engine is in "diet" mode.</span>
	<span class="c1">// ...</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
	<span class="c1">// Engine was compiled in standard mode.</span>
	<span class="c1">// ...</span>
<span class="p">}</span></code></pre></div><p><br/> With Python, we can either check the <em>diet</em> mode via the function <strong>cs_support</strong> of <em>capstone</em> module, as followings.</p><div class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">capstone</span> <span class="kn">import</span> <span class="o">*</span>

<span class="k">if</span> <span class="n">cs_support</span><span class="p">(</span><span class="n">CS_SUPPORT_DIET</span><span class="p">):</span>
    <span class="c"># engine is in diet mode</span>
    <span class="c"># ....</span>
<span class="k">else</span><span class="p">:</span>
    <span class="c"># engine was compiled in standard mode</span>
    <span class="c"># ....</span></code></pre></div><p><br/> Or we can also use the <strong>diet</strong> getter of <em>Cs</em> class for the same purpose, as followings.</p><div class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">cs</span> <span class="o">=</span> <span class="n">Cs</span><span class="p">(</span><span class="n">CS_ARCH_X86</span><span class="p">,</span> <span class="n">CS_MODE_64</span><span class="p">)</span>
<span class="k">if</span> <span class="n">cs</span><span class="o">.</span><span class="n">diet</span><span class="p">:</span>
    <span class="c"># engine is in diet mode</span>
    <span class="c"># ....</span>
<span class="k">else</span><span class="p">:</span>
    <span class="c"># engine was compiled in standard mode</span>
    <span class="c"># ....</span></code></pre></div></section> <footer> </footer></div></body></html>