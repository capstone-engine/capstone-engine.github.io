<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Capstone - Embed engine</title><link rel="stylesheet" href="css/style.css" type="text/css" media="all"><link rel="stylesheet" href="css/pygments.css" type="text/css" media="all"><link rel="alternate" href="feed/index.xml" type="application/atom+xml" title="Atom Feed"></head><body><div id="fb-root"></div> <script>!function(e,t,n){var c,o=e.getElementsByTagName(t)[0];e.getElementById(n)||(c=e.createElement(t),c.id=n,c.src="//connect.facebook.net/en_US/all.js#xfbml=1",o.parentNode.insertBefore(c,o))}(document,"script","facebook-jssdk")</script><script>!function(t,e,r){var n,s=t.getElementsByTagName(e)[0],i=/^http:/.test(t.location)?"http":"https";t.getElementById(r)||(n=t.createElement(e),n.id=r,n.src=i+"://platform.twitter.com/widgets.js",s.parentNode.insertBefore(n,s))}(document,"script","twitter-wjs")</script><script>!function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="https://apis.google.com/js/plusone.js";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><div class="page"> <header> <a href="index.html" id="cs_home">Capstone</a> <nav> <a href="index.html">Home</a> <a href="download.html">Download</a> <a href="documentation.html">Docs</a> <a href="showcase.html">Showcase</a> <a href="testimonial.html">Testimonials</a> <a href="donation.html">Donate</a> <a href="contact.html">Contact</a> </nav> </header> <section><h2 id="building-embedded-engine">Building embedded engine</h2><p>This documentation introduces necessary steps to build Capstone for embedding into special environments such as firmware or OS kernel.</p><h3 id="building-a-minimized-engine">1. Building a minimized engine</h3><p>Typically, we use Capstone for usual applications, where the library weight does not really matter. Indeed, as of version <em>2.1-RC1</em>, the whole engine is only 1.9 MB including all architectures, and this size raise no issue to most people.</p><p>However, to embed Capstone into special enviroments, such as OS kernel driver or firmware, the engine size should be as small as possible due to space restriction. To achieve this object, we must compile Capstone using special methods.</p><p>To build a minimize engine, consult two documentations below.</p><ul><li><p><a href="compile.html">Build only selected architectures to suite your need</a>.</p></li><li><p><a href="diet.html">Build diet engine</a>.</p></li></ul><h3 id="building-an-embedded-engine">2. Building an embedded engine</h3><p>By default, Capstone is built in <em>standard mode</em>, which just uses <em>system</em>â€™s dynamic memory management functions. In the embedded environment, there might not be such functions, however. For this reason, we need to tell building process that we will use our own dynamic memory functions, rather than standard functions.</p><p>For the first step, build the embedded engine and install with: (demonstration is on *nix systems)</p><div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ CAPSTONE_USE_SYS_DYN_MEM</span><span class="o">=</span>no ./make.sh
<span class="nv">$ </span>sudo ./make.sh install</code></pre></div><p><br/> After this step, the final binaries can be ready to use for embedding.</p><p>NOTE: the observant readers might already see that we can combine step (1) &amp; (2) into one. Indeed, we can simply modify <em>config.mk</em> in one go, including select architectures, configure diet engine and embedded engine, then compile the framework. However, we still present this in 2 steps for the sake of clarity.</p><h3 id="setting-up-dynamic-memory-management">3. Setting up dynamic memory management</h3><p>In step (2) above, we already specified at compile-time that we will use our own dynamic memory management functions, provided by our embedded enviroment. Next, we need to declare these functions.</p><p>Capstone needs the following functions: <em>malloc</em>, <em>calloc</em>, <em>realloc</em>, <em>free</em> &amp; <em>vsnprintf</em>. Unsurprisingly, these functions use exactly the same prototypes of system functions in style of <em>Unix stdlibc</em>, like below.</p><div class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="o">*</span><span class="nf">malloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">calloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">nmemb</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">realloc</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>
<span class="kt">void</span>  <span class="nf">free</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">);</span>
<span class="kt">int</span>   <span class="nf">vsnprintf</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">format</span><span class="p">,</span> <span class="kt">va_list</span> <span class="n">ap</span><span class="p">);</span></code></pre></div><p><br/> Our embedded environment has to prepare these functions: they must be ready for the engine before it can do anything, which means we have to do the setup even before the first call to <em>cs_open()</em>. This is done thanks to the API <em>cs_option()</em> as in the sample below.</p><div class="highlight"><pre><code class="language-c" data-lang="c"><span class="lineno"> 1</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">my_malloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="lineno"> 2</span> <span class="p">{</span>
<span class="lineno"> 3</span>     <span class="c1">// Allocate &amp; return a chunk of memory with @size bytes.</span>
<span class="lineno"> 4</span>     <span class="c1">// ...</span>
<span class="lineno"> 5</span> <span class="p">}</span>
<span class="lineno"> 6</span>
<span class="lineno"> 7</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">my_calloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">nmemb</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="lineno"> 8</span> <span class="p">{</span>
<span class="lineno"> 9</span>     <span class="c1">// Allocate &amp; return @nmemb block of memory, with each block</span>
<span class="lineno">10</span>     <span class="c1">// has the size of @size bytes. Memory must be ZERO out before</span>
<span class="lineno">11</span>     <span class="c1">// returning.</span>
<span class="lineno">12</span>     <span class="c1">// ...</span>
<span class="lineno">13</span> <span class="p">}</span>
<span class="lineno">14</span>
<span class="lineno">15</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">my_realloc</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="lineno">16</span> <span class="p">{</span>
<span class="lineno">17</span>     <span class="c1">// Re-allocate &amp; return memory of former allocation with</span>
<span class="lineno">18</span>     <span class="c1">// new size of @size bytes.</span>
<span class="lineno">19</span>     <span class="c1">// ...</span>
<span class="lineno">20</span> <span class="p">}</span>
<span class="lineno">21</span>
<span class="lineno">22</span> <span class="kt">void</span>  <span class="nf">my_free</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span>
<span class="lineno">23</span> <span class="p">{</span>
<span class="lineno">24</span>     <span class="c1">// Free memory formely allocated by my_malloc/my_calloc/my_realloc.</span>
<span class="lineno">25</span>     <span class="c1">// ...</span>
<span class="lineno">26</span> <span class="p">}</span>
<span class="lineno">27</span>
<span class="lineno">28</span> <span class="kt">int</span>   <span class="nf">my_vsnprintf</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">format</span><span class="p">,</span> <span class="kt">va_list</span> <span class="n">ap</span><span class="p">)</span>
<span class="lineno">29</span> <span class="p">{</span>
<span class="lineno">30</span>     <span class="c1">// Write a NULL terminated string to @str, with maximum size of @size bytes.</span>
<span class="lineno">31</span>     <span class="c1">// String is formatted according to @format, with variables provided in @ap.</span>
<span class="lineno">32</span>     <span class="c1">// ...</span>
<span class="lineno">33</span> <span class="p">}</span>
<span class="lineno">34</span>
<span class="lineno">35</span> <span class="c1">// ....</span>
<span class="lineno">36</span> <span class="c1">// Prepare these function for the setup step.</span>
<span class="lineno">37</span> <span class="n">cs_opt_mem</span> <span class="n">setup</span><span class="p">;</span>
<span class="lineno">38</span>
<span class="lineno">39</span> <span class="n">setup</span><span class="p">.</span><span class="n">malloc</span> <span class="o">=</span> <span class="n">my_malloc</span><span class="p">;</span>
<span class="lineno">40</span> <span class="n">setup</span><span class="p">.</span><span class="n">calloc</span> <span class="o">=</span> <span class="n">my_calloc</span><span class="p">;</span>
<span class="lineno">41</span> <span class="n">setup</span><span class="p">.</span><span class="n">realloc</span> <span class="o">=</span> <span class="n">my_realloc</span><span class="p">;</span>
<span class="lineno">42</span> <span class="n">setup</span><span class="p">.</span><span class="n">free</span> <span class="o">=</span> <span class="n">my_free</span><span class="p">;</span>
<span class="lineno">43</span> <span class="n">setup</span><span class="p">.</span><span class="n">vsnprintf</span> <span class="o">=</span> <span class="n">my_vsnprintf</span><span class="p">;</span>
<span class="lineno">44</span>
<span class="lineno">45</span> <span class="c1">// Finally, setup our own dynamic memory functions with cs_option().</span>
<span class="lineno">46</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cs_option</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">CS_OPT_MEM</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">setup</span><span class="p">))</span> <span class="p">{</span>
<span class="lineno">47</span>     <span class="c1">// OK, successfully setup our own dynamic memory management.</span>
<span class="lineno">48</span>     <span class="c1">// From now on, we can use other Capstone APIs.</span>
<span class="lineno">49</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="lineno">50</span>     <span class="c1">// Failed to initialize our user-defined dynamic mem functions.</span>
<span class="lineno">51</span>     <span class="c1">// Quit is the only choice here :-(</span>
<span class="lineno">52</span> <span class="p">}</span></code></pre></div><p><br/> Below is the explanation for each line of this simple code.</p><ul><li><p>Line 1 ~ 33: Declare our own dynamic memory functions with similar prototype to <em>malloc</em>, <em>calloc</em>, <em>realloc</em>, <em>free</em> &amp; <em>vsnprintf</em>.</p></li><li><p>Line 37 ~ 43: Setup a <em>cs_opt_mem</em> structure with our own functions declared above.</p></li><li><p>Line 46: Inform Capstone engine about our own dynamic memory management code using the API <em>cs_option()</em>, which is called with (special) handle <em>0</em> &amp; dedicated option type <em>CS_OPT_MEM</em>. This step is only considered successfully if the returned value is 0.</p></li></ul><p><br/> NOTE: it is <em>illegal</em> to use <em>cs_option()</em> with <em>0</em> as the first argument, as this API expects a valid handle. However, this is acceptable (only) with the option type <em>CS_OPT_MEM</em>, like in this case.</p></section> <footer> </footer></div></body></html>