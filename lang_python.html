<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Capstone - Programming with Python language</title><link rel="stylesheet" href="css/style.css" type="text/css" media="all"><link rel="stylesheet" href="css/pygments.css" type="text/css" media="all"><link rel="alternate" href="feed/index.xml" type="application/atom+xml" title="Atom Feed"></head><body><div id="fb-root"></div> <script>!function(e,t,n){var c,o=e.getElementsByTagName(t)[0];e.getElementById(n)||(c=e.createElement(t),c.id=n,c.src="//connect.facebook.net/en_US/all.js#xfbml=1",o.parentNode.insertBefore(c,o))}(document,"script","facebook-jssdk")</script><script>!function(t,e,r){var n,s=t.getElementsByTagName(e)[0],i=/^http:/.test(t.location)?"http":"https";t.getElementById(r)||(n=t.createElement(e),n.id=r,n.src=i+"://platform.twitter.com/widgets.js",s.parentNode.insertBefore(n,s))}(document,"script","twitter-wjs")</script><script>!function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="https://apis.google.com/js/plusone.js";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><div class="page"> <header> <a href="index.html" id="cs_home">Capstone</a> <nav> <a href="index.html">Home</a> <a href="download.html">Download</a> <a href="documentation.html">Docs</a> <a href="showcase.html">Showcase</a> <a href="testimonial.html">Testimonials</a> <a href="donate.html">Donate</a> <a href="contact.html">Contact</a> </nav> </header> <section><h2 id="python-tutorial-for-capstone">Python tutorial for Capstone</h2><h3 id="basic-sample">1. Basic sample</h3><p>Capstone has a very simple API, so it is very easy to write tools using the framework. To start, the below code disassembles some X86 binary, and prints out its assembly.</p><div class="highlight"><pre><code class="language-python" data-lang="python"><span class="lineno">1</span> <span class="c"># test1.py</span>
<span class="lineno">2</span> <span class="kn">from</span> <span class="nn">capstone</span> <span class="kn">import</span> <span class="o">*</span>
<span class="lineno">3</span>
<span class="lineno">4</span> <span class="n">CODE</span> <span class="o">=</span> <span class="n">b</span><span class="s">"</span><span class="se">\x55\x48\x8b\x05\xb8\x13\x00\x00</span><span class="s">"</span>
<span class="lineno">5</span>
<span class="lineno">6</span> <span class="n">md</span> <span class="o">=</span> <span class="n">Cs</span><span class="p">(</span><span class="n">CS_ARCH_X86</span><span class="p">,</span> <span class="n">CS_MODE_64</span><span class="p">)</span>
<span class="lineno">7</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">md</span><span class="o">.</span><span class="n">disasm</span><span class="p">(</span><span class="n">CODE</span><span class="p">,</span> <span class="mh">0x1000</span><span class="p">):</span>
<span class="lineno">8</span>     <span class="k">print</span><span class="p">(</span><span class="s">"0x</span><span class="si">%x</span><span class="s">:</span><span class="se">\t</span><span class="si">%s</span><span class="se">\t</span><span class="si">%s</span><span class="s">"</span> <span class="o">%</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">address</span><span class="p">,</span> <span class="n">i</span><span class="o">.</span><span class="n">mnemonic</span><span class="p">,</span> <span class="n">i</span><span class="o">.</span><span class="n">op_str</span><span class="p">))</span></code></pre></div><p><br/> Readers can download the code from <a href="/samples/test1.py">here</a>. Output of this sample is like below:</p><div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>python test1.py

0x1000:	push	rbp
0x1001:	mov	rax, qword ptr <span class="o">[</span>rip + 0x13b8<span class="o">]</span></code></pre></div><p><br/> The Python sample is intuitive, right? But just in case, readers can find below the explanation for each line of <em>test1.py</em>.</p><ul><li><p>Line 2: Import Python module <strong>capstone</strong> before we do anything.</p></li><li><p>Line 4: Raw binary code we want to disassemble. The code in this sample is in hex mode.</p></li><li><p>Line 6: Initialize Python class for Capstone with class <strong>Cs</strong>. We need to give this class two arguments: the hardware architecture &amp; the hardware mode. In this sample, we want to disassemble 64-bit code for X86 architecture.</p></li><li><p>Line 7: Disassemble the binary code with method <strong>disasm()</strong> of the class <em>Cs</em> class instance we created above. The second argument of <em>disasm</em> is the address of the first instruction, which is <em>0x1000</em> in this case. By default, <em>disasm</em> disassembles all the code until either there is no more code, or it encounters a broken instruction. In return, <em>disasm</em> gives back a list of instructions of the class type <strong>CsInsn</strong>, and the <em>for</em> loop here iterates this list.</p></li><li><p>Line 8: Print out some internal information about this instruction. Class <em>CsInsn</em> exposes all the internal information about the disassembled instruction that we want to access to. Some of the most used fields of this class are presented below.</p></li></ul><table><thead><tr><th>Field</th><th>Meaning</th></tr></thead><tbody><tr><td>id</td><td>Instruction ID of the instruction. This field has data type <em>int</em>.</td></tr><tr><td>address</td><td>Address of the instruction. This field has <em>int</em> type.</td></tr><tr><td>mnemonic</td><td>Mnemonic of the instruction. This field has <em>string</em> type.</td></tr><tr><td>op_str</td><td>Operands of the instruction. This field has <em>string</em> type.</td></tr><tr><td>size</td><td>The size of the instruction, expressed in number of bytes. This field has data type <em>int</em>.</td></tr><tr><td>bytes</td><td>The byte sequence of the instruction. This field has data type <em>array of bytes</em>, and the size of this instruction can also be derived from the length of this array</td></tr></tbody></table><hr/><h3 id="faster-simpler-api-for-basic-information">2. Faster-simpler API for basic information</h3><p>Example in section 1 uses <em>disasm()</em> method to retrieve <em>CsInsn</em> objects. This offers full information available for disassembled instructions. However, if all we want is just basic data such as <em>address</em>, <em>size</em>, <em>mnemonic</em> &amp; <em>op_str</em>, we can use a lighter API <em>disasm_lite()</em>.</p><p>From version <em>2.1</em>, Python binding provides this new method <em>disasm_lite()</em> in <em>Cs</em> class. Unlike <em>disasm()</em>, <em>disasm_lite()</em> just returns tuples of (<em>address</em>, <em>size</em>, <em>mnemonic</em>, <em>op_str</em>). Benchmarks show that this light API is up to <em>30% faster</em> than its counterpart.</p><p>Below is an example of <em>disasm_lite()</em>, which is self-explanatory.</p><div class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">capstone</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">CODE</span> <span class="o">=</span> <span class="n">b</span><span class="s">"</span><span class="se">\x55\x48\x8b\x05\xb8\x13\x00\x00</span><span class="s">"</span>

<span class="n">md</span> <span class="o">=</span> <span class="n">Cs</span><span class="p">(</span><span class="n">CS_ARCH_X86</span><span class="p">,</span> <span class="n">CS_MODE_64</span><span class="p">)</span>
<span class="k">for</span> <span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">mnemonic</span><span class="p">,</span> <span class="n">op_str</span><span class="p">)</span> <span class="ow">in</span> <span class="n">md</span><span class="o">.</span><span class="n">disasm_lite</span><span class="p">(</span><span class="n">CODE</span><span class="p">,</span> <span class="mh">0x1000</span><span class="p">):</span>
	<span class="k">print</span><span class="p">(</span><span class="s">"0x</span><span class="si">%x</span><span class="s">:</span><span class="se">\t</span><span class="si">%s</span><span class="se">\t</span><span class="si">%s</span><span class="s">"</span> <span class="o">%</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">mnemonic</span><span class="p">,</span> <span class="n">op_str</span><span class="p">))</span></code></pre></div><hr/><h3 id="architectures-and-modes">3. Architectures and modes</h3><p>At the moment, Capstone supports 8 hardware architectures with corresponding hardware modes, as followings.</p><p><br/></p><table><thead><tr><th>Architecture</th><th>Basic mode</th></tr></thead><tbody><tr><td>CS_ARCH_ARM<br/><em>ARM architecture</em></td><td>CS_MODE_ARM: <em>Arm mode</em><br/>CS_MODE_THUMB: <em>Thumb mode</em></td></tr><tr><td>CS_ARCH_ARM64<br/><em>ARMv8/AArch64 architecture</em></td><td>CS_MODE_ARM: <em>default mode</em></td></tr><tr><td>CS_ARCH_MIPS<br/><em>Mips architecture</em></td><td>CS_MODE_MIPS32: <em>Mips32 mode</em><br/>CS_MODE_MIPS64: <em>Mips64 mode</em><br/>CS_MODE_MIPS32R6: <em>Mips32R6 mode</em></td></tr><tr><td>CS_ARCH_PPC<br/><em>PowerPC architecture</em></td><td>CS_MODE_32: <em>32-bit mode</em><br/>CS_MODE_64: <em>64-bit mode</em></td></tr><tr><td>CS_ARCH_SPARC<br/><em>Sparc architecture</em></td><td> </td></tr><tr><td>CS_ARCH_SYSZ<br/><em>SystemZ architecture</em></td><td> </td></tr><tr><td>CS_ARCH_X86<br/><em>X86 architecture</em></td><td>CS_MODE_16: <em>16-bit mode</em><br/>CS_MODE_32: <em>32-bit mode</em><br/>CS_MODE_64: <em>64-bit mode</em></td></tr><tr><td>CS_ARCH_XCORE<br/><em>XCore architecture</em></td><td> </td></tr></tbody></table><p><br/> Besides, there are few modes to be combined with basic modes above.</p><table><thead><tr><th>Extra mode</th><th>Combined with</th></tr></thead><tbody><tr><td>CS_MODE_LITTLE_ENDIAN<br/><em>Little endian mode</em></td><td>CS_MODE_ARM, CS_MODE_THUMB, CS_MODE_32, CS_MODE_64, CS_MODE_MIPS32, CS_MODE_MIPS64, CS_MODE_MIPS32R6</td></tr><tr><td>CS_MODE_BIG_ENDIAN<br/><em>Big endian mode</em></td><td>CS_MODE_ARM, CS_MODE_THUMB, CS_MODE_32, CS_MODE_64, CS_MODE_MIPS32, CS_MODE_MIPS64, CS_MODE_MIPS32R6</td></tr><tr><td>CS_MODE_MICRO<br/><em>MicroMips mode</em></td><td>CS_MODE_MIPS32, CS_MODE_MIPS64, CS_MODE_MIPS32R6</td></tr><tr><td>CS_MODE_MCLASS<br/><em>MClass mode</em></td><td>CS_MODE_ARM</td></tr><tr><td>CS_MODE_V8<br/><em>ARM V8 mode</em></td><td>CS_MODE_ARM, CS_MODE_THUMB</td></tr><tr><td>CS_MODE_V9<br/><em>Sparc V9 mode</em></td><td>CS_MODE_BIG_ENDIAN</td></tr></tbody></table><p><br/> The way to combine extra modes with basic modes is to use the operand <code>+</code>. For example, the code below disassembles some Mips64 code in <em>little endian</em> mode.</p><div class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">capstone</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">CODE</span> <span class="o">=</span> <span class="n">b</span><span class="s">"</span><span class="se">\x56\x34\x21\x34\xc2\x17\x01\x00</span><span class="s">"</span>

<span class="n">md</span> <span class="o">=</span> <span class="n">Cs</span><span class="p">(</span><span class="n">CS_ARCH_MIPS</span><span class="p">,</span> <span class="n">CS_MODE_MIPS64</span> <span class="o">+</span> <span class="n">CS_MODE_LITTLE_ENDIAN</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">md</span><span class="o">.</span><span class="n">disasm</span><span class="p">(</span><span class="n">CODE</span><span class="p">,</span> <span class="mh">0x1000</span><span class="p">):</span>
	<span class="k">print</span><span class="p">(</span><span class="s">"</span><span class="si">%x</span><span class="s">:</span><span class="se">\t</span><span class="si">%s</span><span class="se">\t</span><span class="si">%s</span><span class="s">"</span> <span class="o">%</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">address</span><span class="p">,</span> <span class="n">i</span><span class="o">.</span><span class="n">mnemonic</span><span class="p">,</span> <span class="n">i</span><span class="o">.</span><span class="n">op_str</span><span class="p">))</span></code></pre></div><hr/><h3 id="more-architecture-independent-data-for-disassembled-instructions">4. More architecture-independent data for disassembled instructions</h3><p>By default, Capstone do not generate details for disassembled instruction. If we want information such as implicit registers read/written or semantic groups that this instruction belongs to, we need to explicitly turn this option <em>on</em>, like in the sample code below.</p><div class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">md</span> <span class="o">=</span> <span class="n">Cs</span><span class="p">(</span><span class="n">CS_ARCH_X86</span><span class="p">,</span> <span class="n">CS_MODE_32</span><span class="p">)</span>
<span class="n">md</span><span class="o">.</span><span class="n">detail</span> <span class="o">=</span> <span class="bp">True</span></code></pre></div><p>However, keep in mind that producing details costs more memory, complicates the internal operations and slows down the engine a bit, so only do that if needed. If this is no longer desired, we can always reset the engine back to default state at run-time with similar method.</p><div class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">md</span><span class="o">.</span><span class="n">detail</span> <span class="o">=</span> <span class="bp">False</span></code></pre></div><p>Details produced by Capstone provides access to a lot more internal data of the disassembled instruction than the fields introduced in the last sections. Note that these data are all architecture-independent.</p><p>The sample below shows how to extract out details on implicit registers being read by instructions, as well as all the semantic groups this instruction belongs to in some ARM binary.</p><div class="highlight"><pre><code class="language-python" data-lang="python"><span class="lineno"> 1</span> <span class="kn">from</span> <span class="nn">capstone</span> <span class="kn">import</span> <span class="o">*</span>
<span class="lineno"> 2</span> <span class="kn">from</span> <span class="nn">capstone.arm</span> <span class="kn">import</span> <span class="o">*</span>
<span class="lineno"> 3</span>
<span class="lineno"> 4</span> <span class="n">CODE</span> <span class="o">=</span> <span class="n">b</span><span class="s">"</span><span class="se">\xf1\x02\x03\x0e\x00\x00\xa0\xe3\x02\x30\xc1\xe7\x00\x00\x53\xe3</span><span class="s">"</span>
<span class="lineno"> 5</span>
<span class="lineno"> 6</span> <span class="n">md</span> <span class="o">=</span> <span class="n">Cs</span><span class="p">(</span><span class="n">CS_ARCH_ARM</span><span class="p">,</span> <span class="n">CS_MODE_ARM</span><span class="p">)</span>
<span class="lineno"> 7</span> <span class="n">md</span><span class="o">.</span><span class="n">detail</span> <span class="o">=</span> <span class="bp">True</span>
<span class="lineno"> 8</span>
<span class="lineno"> 9</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">md</span><span class="o">.</span><span class="n">disasm</span><span class="p">(</span><span class="n">CODE</span><span class="p">,</span> <span class="mh">0x1000</span><span class="p">):</span>
<span class="lineno">10</span>     <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">id</span> <span class="ow">in</span> <span class="p">(</span><span class="n">ARM_INS_BL</span><span class="p">,</span> <span class="n">ARM_INS_CMP</span><span class="p">):</span>
<span class="lineno">11</span>         <span class="k">print</span><span class="p">(</span><span class="s">"0x</span><span class="si">%x</span><span class="s">:</span><span class="se">\t</span><span class="si">%s</span><span class="se">\t</span><span class="si">%s</span><span class="s">"</span> <span class="o">%</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">address</span><span class="p">,</span> <span class="n">i</span><span class="o">.</span><span class="n">mnemonic</span><span class="p">,</span> <span class="n">i</span><span class="o">.</span><span class="n">op_str</span><span class="p">))</span>
<span class="lineno">12</span>
<span class="lineno">13</span>         <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">regs_read</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
<span class="lineno">14</span>             <span class="k">print</span><span class="p">(</span><span class="s">"</span><span class="se">\t</span><span class="s">Implicit registers read: "</span><span class="p">),</span>
<span class="lineno">15</span>             <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">i</span><span class="o">.</span><span class="n">regs_read</span><span class="p">:</span>
<span class="lineno">16</span>                 <span class="k">print</span><span class="p">(</span><span class="s">"</span><span class="si">%s</span><span class="s"> "</span> <span class="o">%</span><span class="n">i</span><span class="o">.</span><span class="n">reg_name</span><span class="p">(</span><span class="n">r</span><span class="p">)),</span>
<span class="lineno">17</span>             <span class="k">print</span>
<span class="lineno">18</span>
<span class="lineno">19</span>         <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">groups</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
<span class="lineno">20</span>             <span class="k">print</span><span class="p">(</span><span class="s">"</span><span class="se">\t</span><span class="s">This instruction belongs to groups:"</span><span class="p">),</span>
<span class="lineno">21</span>             <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">i</span><span class="o">.</span><span class="n">groups</span><span class="p">:</span>
<span class="lineno">22</span>                 <span class="k">print</span><span class="p">(</span><span class="s">"</span><span class="si">%u</span><span class="s">"</span> <span class="o">%</span><span class="n">g</span><span class="p">),</span>
<span class="lineno">23</span>             <span class="k">print</span></code></pre></div><p><br/> Readers might already figure out how the code above work, as it is simple enough:</p><ul><li><p>Line 2: Import <em>arm</em> module, since we want to work with ARM architecture here.</p></li><li><p>Line 6 ~ 7: Initialize engine with Arm mode for Arm architecture, then turn on detail feature.</p></li><li><p>Line 9: Disassemble the Arm binary, then iterate the disassembled instructions.</p></li><li><p>Line 10: In this example, we only care about some instructions, which is <em>bl</em> &amp; <em>cmp</em>, and ignore everything else. All the constant numbers can be found in file <strong>arm_const.py</strong> in the source of Python binding.</p></li><li><p>Line 13: Check if this instruction <em>implicitly</em> reads any registers. If so, print out all register names</p></li><li><p>Line 16: While we can simply print out the register ID (which has <em>int</em> type), it is more friendly to print out register name instead. This can be done with method <strong>reg_name()</strong>, which receives the register ID as its only argument.</p></li><li><p>Line 19: Check if this instruction belongs to any semantic group. If so, print out all group ID.</p></li><li><p>Line 21 ~ 22: Print out all the group IDs in a loop.</p></li></ul><p><br/> The output of the above sample is like below.</p><div class="highlight"><pre><code class="language-objdump" data-lang="objdump"><span class="x">0x1000:	bl	#0x104c</span>
<span class="x">		Implicit registers read:  pc</span>
<span class="x">		This instruction belongs to groups: 20</span>
<span class="x">0x101c:	cmp	r3, #0</span>
<span class="x">		This instruction belongs to groups: 20</span></code></pre></div><hr/><h3 id="architecture-dependent-details">5. Architecture-dependent details</h3><p>When detail option is on, <em>CsInsn</em> provides a field named <strong>operands</strong>, which is a list of all operands of the instruction. Unlike the fields presented in section 4 above, this field is different for each architecture.</p><p>The sample below shows how to extract the details on instruction operands of ARM64 code.</p><div class="highlight"><pre><code class="language-python" data-lang="python"><span class="lineno"> 1</span> <span class="kn">from</span> <span class="nn">capstone</span> <span class="kn">import</span> <span class="o">*</span>
<span class="lineno"> 2</span> <span class="kn">from</span> <span class="nn">capstone.arm64</span> <span class="kn">import</span> <span class="o">*</span>
<span class="lineno"> 3</span>
<span class="lineno"> 4</span> <span class="n">CODE</span> <span class="o">=</span> <span class="n">b</span><span class="s">"</span><span class="se">\xe1\x0b\x40\xb9\x20\x04\x81\xda\x20\x08\x02\x8b</span><span class="s">"</span>
<span class="lineno"> 5</span>
<span class="lineno"> 6</span> <span class="n">md</span> <span class="o">=</span> <span class="n">Cs</span><span class="p">(</span><span class="n">CS_ARCH_ARM64</span><span class="p">,</span> <span class="n">CS_MODE_ARM</span><span class="p">)</span>
<span class="lineno"> 7</span> <span class="n">md</span><span class="o">.</span><span class="n">detail</span> <span class="o">=</span> <span class="bp">True</span>
<span class="lineno"> 8</span>
<span class="lineno"> 9</span> <span class="k">for</span> <span class="n">insn</span> <span class="ow">in</span> <span class="n">md</span><span class="o">.</span><span class="n">disasm</span><span class="p">(</span><span class="n">CODE</span><span class="p">,</span> <span class="mh">0x38</span><span class="p">):</span>
<span class="lineno">10</span>     <span class="k">print</span><span class="p">(</span><span class="s">"0x</span><span class="si">%x</span><span class="s">:</span><span class="se">\t</span><span class="si">%s</span><span class="se">\t</span><span class="si">%s</span><span class="s">"</span> <span class="o">%</span><span class="p">(</span><span class="n">insn</span><span class="o">.</span><span class="n">address</span><span class="p">,</span> <span class="n">insn</span><span class="o">.</span><span class="n">mnemonic</span><span class="p">,</span> <span class="n">insn</span><span class="o">.</span><span class="n">op_str</span><span class="p">))</span>
<span class="lineno">11</span>
<span class="lineno">12</span>     <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">insn</span><span class="o">.</span><span class="n">operands</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
<span class="lineno">13</span>         <span class="k">print</span><span class="p">(</span><span class="s">"</span><span class="se">\t</span><span class="s">Number of operands: </span><span class="si">%u</span><span class="s">"</span> <span class="o">%</span><span class="nb">len</span><span class="p">(</span><span class="n">insn</span><span class="o">.</span><span class="n">operands</span><span class="p">))</span>
<span class="lineno">14</span>         <span class="n">c</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="lineno">15</span>         <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">insn</span><span class="o">.</span><span class="n">operands</span><span class="p">:</span>
<span class="lineno">16</span>             <span class="n">c</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="lineno">17</span>             <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">ARM64_OP_REG</span><span class="p">:</span>
<span class="lineno">18</span>                 <span class="k">print</span><span class="p">(</span><span class="s">"</span><span class="se">\t\t</span><span class="s">operands[</span><span class="si">%u</span><span class="s">].type: REG = </span><span class="si">%s</span><span class="s">"</span> <span class="o">%</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">insn</span><span class="o">.</span><span class="n">reg_name</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">reg</span><span class="p">)))</span>
<span class="lineno">19</span>             <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">ARM64_OP_IMM</span><span class="p">:</span>
<span class="lineno">20</span>                 <span class="k">print</span><span class="p">(</span><span class="s">"</span><span class="se">\t\t</span><span class="s">operands[</span><span class="si">%u</span><span class="s">].type: IMM = 0x</span><span class="si">%x</span><span class="s">"</span> <span class="o">%</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">i</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">imm</span><span class="p">))</span>
<span class="lineno">21</span>             <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">ARM64_OP_CIMM</span><span class="p">:</span>
<span class="lineno">22</span>                 <span class="k">print</span><span class="p">(</span><span class="s">"</span><span class="se">\t\t</span><span class="s">operands[</span><span class="si">%u</span><span class="s">].type: C-IMM = </span><span class="si">%u</span><span class="s">"</span> <span class="o">%</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">i</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">imm</span><span class="p">))</span>
<span class="lineno">23</span>             <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">ARM64_OP_FP</span><span class="p">:</span>
<span class="lineno">24</span>                 <span class="k">print</span><span class="p">(</span><span class="s">"</span><span class="se">\t\t</span><span class="s">operands[</span><span class="si">%u</span><span class="s">].type: FP = </span><span class="si">%f</span><span class="s">"</span> <span class="o">%</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">i</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">fp</span><span class="p">))</span>
<span class="lineno">25</span>             <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">ARM64_OP_MEM</span><span class="p">:</span>
<span class="lineno">26</span>                 <span class="k">print</span><span class="p">(</span><span class="s">"</span><span class="se">\t\t</span><span class="s">operands[</span><span class="si">%u</span><span class="s">].type: MEM"</span> <span class="o">%</span><span class="n">c</span><span class="p">)</span>
<span class="lineno">27</span>                 <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">mem</span><span class="o">.</span><span class="n">base</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
<span class="lineno">28</span>                     <span class="k">print</span><span class="p">(</span><span class="s">"</span><span class="se">\t\t\t</span><span class="s">operands[</span><span class="si">%u</span><span class="s">].mem.base: REG = </span><span class="si">%s</span><span class="s">"</span> \
<span class="lineno">29</span>                         <span class="o">%</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">insn</span><span class="o">.</span><span class="n">reg_name</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">mem</span><span class="o">.</span><span class="n">base</span><span class="p">)))</span>
<span class="lineno">30</span>                 <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">mem</span><span class="o">.</span><span class="n">index</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
<span class="lineno">31</span>                     <span class="k">print</span><span class="p">(</span><span class="s">"</span><span class="se">\t\t\t</span><span class="s">operands[</span><span class="si">%u</span><span class="s">].mem.index: REG = </span><span class="si">%s</span><span class="s">"</span> \
<span class="lineno">32</span>                         <span class="o">%</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">insn</span><span class="o">.</span><span class="n">reg_name</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">mem</span><span class="o">.</span><span class="n">index</span><span class="p">)))</span>
<span class="lineno">33</span>                 <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">mem</span><span class="o">.</span><span class="n">disp</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
<span class="lineno">34</span>                     <span class="k">print</span><span class="p">(</span><span class="s">"</span><span class="se">\t\t\t</span><span class="s">operands[</span><span class="si">%u</span><span class="s">].mem.disp: 0x</span><span class="si">%x</span><span class="s">"</span> \
<span class="lineno">35</span>                         <span class="o">%</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">i</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">mem</span><span class="o">.</span><span class="n">disp</span><span class="p">))</span>
<span class="lineno">36</span>
<span class="lineno">37</span>             <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">shift</span><span class="o">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">ARM64_SFT_INVALID</span> <span class="ow">and</span> <span class="n">i</span><span class="o">.</span><span class="n">shift</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
<span class="lineno">38</span> 	            <span class="k">print</span><span class="p">(</span><span class="s">"</span><span class="se">\t\t\t</span><span class="s">Shift: type = </span><span class="si">%u</span><span class="s">, value = </span><span class="si">%u</span><span class="s">"</span> \
<span class="lineno">39</span>                     <span class="o">%</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">shift</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">i</span><span class="o">.</span><span class="n">shift</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>
<span class="lineno">40</span>
<span class="lineno">41</span>             <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">ext</span> <span class="o">!=</span> <span class="n">ARM64_EXT_INVALID</span><span class="p">:</span>
<span class="lineno">42</span> 	            <span class="k">print</span><span class="p">(</span><span class="s">"</span><span class="se">\t\t\t</span><span class="s">Ext: </span><span class="si">%u</span><span class="s">"</span> <span class="o">%</span><span class="n">i</span><span class="o">.</span><span class="n">ext</span><span class="p">)</span>
<span class="lineno">43</span>
<span class="lineno">44</span>     <span class="k">if</span> <span class="n">insn</span><span class="o">.</span><span class="n">writeback</span><span class="p">:</span>
<span class="lineno">45</span>         <span class="k">print</span><span class="p">(</span><span class="s">"</span><span class="se">\t</span><span class="s">Write-back: True"</span><span class="p">)</span>
<span class="lineno">46</span>     <span class="k">if</span> <span class="ow">not</span> <span class="n">insn</span><span class="o">.</span><span class="n">cc</span> <span class="ow">in</span> <span class="p">[</span><span class="n">ARM64_CC_AL</span><span class="p">,</span> <span class="n">ARM64_CC_INVALID</span><span class="p">]:</span>
<span class="lineno">47</span>         <span class="k">print</span><span class="p">(</span><span class="s">"</span><span class="se">\t</span><span class="s">Code condition: </span><span class="si">%u</span><span class="s">"</span> <span class="o">%</span><span class="n">insn</span><span class="o">.</span><span class="n">cc</span><span class="p">)</span>
<span class="lineno">48</span>     <span class="k">if</span> <span class="n">insn</span><span class="o">.</span><span class="n">update_flags</span><span class="p">:</span>
<span class="lineno">49</span>         <span class="k">print</span><span class="p">(</span><span class="s">"</span><span class="se">\t</span><span class="s">Update-flags: True"</span><span class="p">)</span></code></pre></div><p><br/> The code looks a bit complicated, but actually pretty simple:</p><ul><li><p>Line 12: Check if this instruction has any operands to print out.</p></li><li><p>Line 17 ~ 18: If this operand is register (reflected by type <em>ARM64_OP_REG</em>), then print out its register name.</p></li><li><p>Line 19 ~ 20: If this operand is immediate (reflected by type <em>ARM64_OP_IMM</em>), then print out its numerical value.</p></li><li><p>Line 21 ~ 22: If this operand is of type C-IMM (coprocessor register type, reflected by <em>ARM64_OP_CIMM</em>), then print out its index value.</p></li><li><p>Line 23 ~ 24: If this operand is real number (reflected by type <em>ARM64_OP_FP</em>), then print out its numerical value.</p></li><li><p>Line 25 ~ 35: If this operand is memory reference (reflected by type <em>ARM64_OP_MEM</em>), then print out its base/index registers, together with offset value.</p></li><li><p>Line 37 ~ 42: If this operand uses shift or extender, print out their value.</p></li><li><p>Line 44 ~ 45: If this instruction writes back its value afterwards, print out that.</p></li><li><p>Line 46 ~ 47: Print out the code condition of this instruction.</p></li><li><p>Line 48 ~ 49: If this instruction update flags, print out that.</p></li></ul><p><br/> The output of the above sample is like below.</p><div class="highlight"><pre><code class="language-objdump" data-lang="objdump"><span class="x">0x38:	ldr	w1, [sp, #8]</span>
<span class="x">	Number of operands: 2</span>
<span class="x">		operands[0].type: REG = w1</span>
<span class="x">		operands[1].type: MEM</span>
<span class="x">			operands[1].mem.base: REG = sp</span>
<span class="x">			operands[1].mem.disp: 0x8</span>

<span class="x">0x3c:	csneg	x0, x1, x1, eq</span>
<span class="x">	Number of operands: 3</span>
<span class="x">		operands[0].type: REG = x0</span>
<span class="x">		operands[1].type: REG = x1</span>
<span class="x">		operands[2].type: REG = x1</span>
<span class="x">	Code condition: 1</span>

<span class="x">0x40:	add	x0, x1, x2, lsl #2</span>
<span class="x">	Number of operands: 3</span>
<span class="x">		operands[0].type: REG = x0</span>
<span class="x">		operands[1].type: REG = x1</span>
<span class="x">		operands[2].type: REG = x2</span>
<span class="x">			Shift: type = 1, value = 2</span></code></pre></div><hr/><h3 id="run-time-options">6. Run-time options</h3><p>Besides the <em>detail</em> option previously introduced in section 4, Capstone can customize the engine at run-time, allowing us to set the assembly syntax or dynamically change engine’s mode.</p><h4 id="syntax-option">6.1 Syntax option</h4><p>By default, X86 assembly outputs in Intel syntax. To switch to AT&amp;T syntax instead, we can simply set syntax option like below.</p><div class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">md</span> <span class="o">=</span> <span class="n">Cs</span><span class="p">(</span><span class="n">CS_ARCH_X86</span><span class="p">,</span> <span class="n">CS_MODE_32</span><span class="p">)</span>
<span class="n">md</span><span class="o">.</span><span class="n">syntax</span> <span class="o">=</span> <span class="n">CS_OPT_SYNTAX_ATT</span></code></pre></div><p><br/> In case we want to return to Intel syntax, we can reset the syntax in the similar way:</p><div class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">md</span><span class="o">.</span><span class="n">syntax</span> <span class="o">=</span> <span class="n">CS_OPT_SYNTAX_INTEL</span></code></pre></div><h4 id="dynamically-change-disassemble-mode-at-run-time">6.2 Dynamically change disassemble mode at run-time</h4><p>From version 2.0, we can dynamically change the engine’s mode at run-time thanks to a new option <strong>mode</strong>.</p><p>This is useful for example with Arm, where we might frequently switch between Arm &amp; Thumb modes without having to create a new engine. This also happens with X86, where we might want to switch back and forth between protected-mode &amp; real-mode code.</p><p>Below sample shows how to switch back and forth between Arm &amp; Thumb modes at run-time.</p><div class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">md</span> <span class="o">=</span> <span class="n">Cs</span><span class="p">(</span><span class="n">CS_ARCH_ARM</span><span class="p">,</span> <span class="n">CS_MODE_ARM</span><span class="p">)</span> <span class="c"># dynamically switch to Arm mode</span>
<span class="c"># from now on disassemble Arm code ....</span>

<span class="n">md</span><span class="o">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">CS_MODE_THUMB</span> <span class="c"># dynamically change to Thumb mode</span>
<span class="c"># from now on disassemble Thumb code ....</span>

<span class="n">md</span><span class="o">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">CS_MODE_ARM</span> <span class="c"># change back to Arm mode again</span>
<span class="c"># from now on disassemble Arm code ....</span></code></pre></div><hr/><h3 id="diet-engine">7. Diet engine</h3><p>From version 2.1, Capstone supports “diet” compilation option to minimize the engine for embedded purpose. The <em>diet</em> engine no longer updates some data fields of the <em>CsInsn</em> class, so these fields &amp; some related APIs become irrelevant. See <a href="diet.html">this documentation</a> for further information.</p><hr/><h3 id="more-examples">8. More examples</h3><p>This tutorial does not explain all the API of Capstone yet. Please find more advanced examples in source of <em>test_*.py</em> files under Python binding directory <a href="https://github.com/aquynh/capstone/tree/master/bindings/python">bindings/python</a> in the Capstone source code.</p></section> <footer> </footer></div></body></html>