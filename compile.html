<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Capstone - Arch-selected libraries</title><link rel="stylesheet" href="css/style.css" type="text/css" media="all"><link rel="stylesheet" href="css/pygments.css" type="text/css" media="all"><link rel="alternate" href="feed/index.xml" type="application/atom+xml" title="Atom Feed"></head><body><div id="fb-root"></div> <script>!function(e,t,n){var c,o=e.getElementsByTagName(t)[0];e.getElementById(n)||(c=e.createElement(t),c.id=n,c.src="//connect.facebook.net/en_US/all.js#xfbml=1",o.parentNode.insertBefore(c,o))}(document,"script","facebook-jssdk")</script><script>!function(t,e,r){var n,s=t.getElementsByTagName(e)[0],i=/^http:/.test(t.location)?"http":"https";t.getElementById(r)||(n=t.createElement(e),n.id=r,n.src=i+"://platform.twitter.com/widgets.js",s.parentNode.insertBefore(n,s))}(document,"script","twitter-wjs")</script><script>!function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="https://apis.google.com/js/plusone.js";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><div class="page"> <header> <a href="index.html" id="cs_home">Capstone</a> <nav> <a href="index.html">Home</a> <a href="download.html">Download</a> <a href="documentation.html">Docs</a> <a href="showcase.html">Showcase</a> <a href="testimonial.html">Testimonials</a> <a href="donate.html">Donate</a> <a href="contact.html">Contact</a> </nav> </header> <section><h2 id="build--programming-with-arch-selected-engine">Build &amp; programming with arch-selected engine</h2><p>This documentation introduces how to build Capstone to support selected architectures for more compact libraries.</p><p>Later part presents the APIs related to this feature and suggests what programmers need to pay attention in their code.</p><h3 id="building-selected-archs-for-compact-engine">1. Building selected archs for compact engine</h3><p>Capstone is a multi-arch disassembly framework and by default all 5 architectures (Arm, Arm64, Mips, PowerPC &amp; X86) are compiled, thus supported in the final libraries. But Capstone also lets we choose to only build selected architectures, so we can tailor the library to our need.</p><p>The main reason to do this is to have more compact binary to make it easier to embed Capstone into special products and environments (thinking about disassembling from inside OS kernel, or even firmware).</p><p>This customization to the library is done at compile time, and very straightforward: All we need to do is to tell <em>make.sh</em> which architectures we need.</p><p>For example, to compile only <em>ARM</em>, <em>ARM64</em> &amp; <em>X86</em> architectures, do:</p><div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ CAPSTONE_ARCHS</span><span class="o">=</span><span class="s2">"arm aarch64 x86"</span> ./make.sh</code></pre></div><p>The remaining step is to build the libraries and install them with: (demonstration is on *nix systems)</p><div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>./make.sh
<span class="nv">$ </span>sudo ./make.sh install</code></pre></div><p><br/> Find below the librariesâ€™ size for each individual architecture.</p><table><thead><tr><th style="text-align:center">Architecture</th><th style="text-align:left">Library</th><th style="text-align:center">Binary size</th></tr></thead><tbody><tr><td style="text-align:center">Arm</td><td style="text-align:left">libcapstone.a<br/>libcapstone.dylib</td><td style="text-align:center">730 KB<br/>599 KB</td></tr><tr><td style="text-align:center">Arm64</td><td style="text-align:left">libcapstone.a<br/>libcapstone.dylib</td><td style="text-align:center">519 KB<br/>398 KB</td></tr><tr><td style="text-align:center">Mips</td><td style="text-align:left">libcapstone.a<br/>libcapstone.dylib</td><td style="text-align:center">206 KB<br/>164 KB</td></tr><tr><td style="text-align:center">PowerPC</td><td style="text-align:left">libcapstone.a<br/>libcapstone.dylib</td><td style="text-align:center">140 KB<br/>103 KB</td></tr><tr><td style="text-align:center">X86</td><td style="text-align:left">libcapstone.a<br/>libcapstone.dylib</td><td style="text-align:center">809 KB<br/>728 KB</td></tr><tr><td style="text-align:center">Combine all 5 archs</td><td style="text-align:left">libcapstone.a<br/>libcapstone.dylib</td><td style="text-align:center">2.3 MB<br/>1.9 MB</td></tr></tbody></table><p><br/> (Above statistics were collected as of version <em>2.1-rc1</em>, built on Mac OSX 10.9.1 with clang-500.2.79)</p><h3 id="programming-with-arch-selected-engine">2. Programming with arch-selected engine</h3><p>Fortunately, when libraries built with selected architectures, Capstone APIs are still functioning in exactly the same way. However, if our program tries to initialize an absent architecture (which was not compiled in), it would fail. When this happens, we can confirm the issue with the API <strong>cs_errno()</strong>, with would return error type <strong>CS_ERR_ARCH</strong> to indicate this arch is unsupported.</p><p>Therefore, it is a good idea to always check for the returned value of <strong>cs_open()</strong> to make sure nothing is wrong. Coding this in C will be like below.</p><div class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">csh</span> <span class="n">handle</span><span class="p">;</span>

<span class="k">if</span> <span class="p">(</span><span class="n">cs_open</span><span class="p">(</span><span class="n">CS_ARCH_X86</span><span class="p">,</span> <span class="n">CS_MODE_64</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">handle</span><span class="p">)</span> <span class="o">==</span> <span class="n">CS_ERR_OK</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// X86 is supported.</span>
	<span class="c1">// ...</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
	<span class="c1">// X86 was not compiled-in, thus unsupported.</span>
	<span class="c1">// cs_errno() should return 'CS_ERR_ARCH' here.</span>
	<span class="c1">// ...</span>
<span class="p">}</span></code></pre></div><p><br/> Alternatively, we can always verify if a particular arch is supported with the API <strong>cs_support()</strong>, like below (sample code is again in C).</p><div class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">if</span> <span class="p">(</span><span class="n">cs_support</span><span class="p">(</span><span class="n">CS_ARCH_X86</span><span class="p">))</span> <span class="p">{</span>
	<span class="c1">// X86 is supported.</span>
	<span class="c1">// ...</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
	<span class="c1">// X86 was not compiled-in, thus unsupported.</span>
	<span class="c1">// ...</span>
<span class="p">}</span></code></pre></div></section> <footer> </footer></div></body></html>