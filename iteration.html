<!DOCTYPE html>
<html>
  <head>
    <title>Disassemble in iterartion style – Capstone – The Ultimate Disassembler</title>

        <meta charset="utf-8" />
    <meta content='text/html; charset=utf-8' http-equiv='Content-Type'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge'>
    <meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0'>

    
    <meta name="description" content="The Ultimate Disassembler">
    <meta property="og:description" content="The Ultimate Disassembler" />
    
    <meta name="author" content="Capstone" />

    
    <meta property="og:title" content="Disassemble in iterartion style" />
    <meta property="twitter:title" content="Disassemble in iterartion style" />
    

    <link rel="icon" type="image/png" sizes="16x16" href="/16x16.png">
    <link rel="icon" type="image/png" sizes="24x24" href="/24x24.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/32x32.png">
    <link rel="icon" type="image/png" sizes="48x48" href="/48x48.png">
    <link rel="icon" type="image/png" sizes="64x64" href="/64x64.png">
    <link rel="icon" type="image/png" sizes="96x96" href="/96x96.png">
    <link rel="icon" type="image/png" sizes="128x128" href="/128x128.png">
    <link rel="icon" type="image/png" sizes="256x256" href="/256x256.png">
    <link rel="icon" type="image/png" sizes="512x512" href="/512x512.png">
    <link rel="manifest" href="/manifest.json">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="msapplication-TileImage" content="/ms-icon-144x144.png">
    <meta name="theme-color" content="#ffffff">


    <!--[if lt IE 9]>
      <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="alternate" type="application/rss+xml" title="Capstone - The Ultimate Disassembler" href="/feed.xml" />

    <!-- Created with Jekyll Now - http://github.com/barryclark/jekyll-now -->
  </head>

  <body>
    <div class="wrapper-masthead">
      <div class="container">
        <header class="masthead clearfix">
          <a href="/" class="site-avatar"><img src="/img/capstone.png" /></a>

          <div class="site-info">
            <h1 class="site-name"><a href="/">Capstone</a></h1>
            <p class="site-description">The Ultimate Disassembler</p>
          </div>

          <nav>
            <a href="/download.html">Download</a>
            <a href="/documentation.html">Docs</a>
            <a href="/showcase.html">Showcase</a>
            <a href="/testimonial.html">Testimonials</a>
            <a href="/donate.html">Donate</a>
            <a href="/contact.html">Contact</a>
          </nav>
        </header>
      </div>
    </div>

    <div id="main" role="main" class="container">
      <h3>1. Introduction of cs<em>disasm</em>iter API.</h3>

<p>The API <em>cs_disasm</em> automatically allocates memory internally for disassembled instructions, which is expensive if we need to decode a lot of instructions.</p>

<p>From version 3.0, Capstone provides <strong>cs<em>disasm</em>iter</strong>, a new API that can improve the performance by up to 30% depending on cases. The principle is: rather than letting the core allocate memory, <em>user pre-allocates the memory required</em>, then pass it to the core, so Capstone can reuse the same memory to store the disassembled instructions. Elimination of many alloc/realloc calls is the reason behind the performance gained.</p>

<p>See below for a sample C code demonstrating this API.</p>

<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="lineno"> 1</span> <span class="n">csh</span> <span class="n">handle</span><span class="p">;</span>
<span class="lineno"> 2</span>     <span class="n">cs_open</span><span class="p">(</span><span class="n">CS_ARCH_X86</span><span class="p">,</span> <span class="n">CS_MODE_32</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">handle</span><span class="p">);</span>
<span class="lineno"> 3</span> 
<span class="lineno"> 4</span>     <span class="c1">// allocate memory cache for 1 instruction, to be used by cs_disasm_iter later.</span>
<span class="lineno"> 5</span>     <span class="n">cs_insn</span> <span class="o">*</span><span class="n">insn</span> <span class="o">=</span> <span class="n">cs_malloc</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
<span class="lineno"> 6</span> 
<span class="lineno"> 7</span>     <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">code</span> <span class="o">=</span> <span class="s">&quot;</span><span class="se">\x90\x91\x92</span><span class="s">&quot;</span><span class="p">;</span>
<span class="lineno"> 8</span>  <span class="kt">size_t</span> <span class="n">code_size</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>  <span class="c1">// size of @code buffer above</span>
<span class="lineno"> 9</span>  <span class="kt">uint64_t</span> <span class="n">address</span> <span class="o">=</span> <span class="mh">0x1000</span><span class="p">;</span> <span class="c1">// address of first instruction to be disassembled</span>
<span class="lineno">10</span> 
<span class="lineno">11</span>     <span class="c1">// disassemble one instruction a time &amp; store the result into @insn variable above</span>
<span class="lineno">12</span>     <span class="k">while</span><span class="p">(</span><span class="n">cs_disasm_iter</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">code</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">code_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">address</span><span class="p">,</span> <span class="n">insn</span><span class="p">))</span> <span class="p">{</span>
<span class="lineno">13</span>         <span class="c1">// analyze disassembled instruction in @insn variable ...</span>
<span class="lineno">14</span>         <span class="c1">// NOTE: @code, @code_size &amp; @address variables are all updated</span>
<span class="lineno">15</span>         <span class="c1">// to point to the next instruction after each iteration.</span>
<span class="lineno">16</span>     <span class="p">}</span>
<span class="lineno">17</span> 
<span class="lineno">18</span>     <span class="c1">// release the cache memory when done</span>
<span class="lineno">19</span>     <span class="n">cs_free</span><span class="p">(</span><span class="n">insn</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span></code></pre></div>

<p><br></p>

<ul>
<li><p>On <em>line 5</em>, we pre-allocate memory for one instruction and keep it in the variable <em>insn</em>. This is done thanks to <strong>cs_malloc</strong>, another new API introduced in Capstone 3.0.</p></li>
<li><p>One <em>line 12</em>, we disassemble one instruction a time in a loop with <em>cs<em>disasm</em>iter</em>, which takes 5 arguments: the Capstone handle, the pointer to the input binary code, the pointer to the size of this input, the pointer to the address of the first instruction &amp; the memory cache generated in <em>line 5</em>. On success, this API updates all these pointers to the next instruction, making it ready for the next iteration in the <em>while</em> loop.</p></li>
</ul>

<p>The API <em>cs<em>disasm</em>iter</em> returns <em>true</em> when it successfully decodes one instruction, or <em>false</em> otherwise. Therefore, readers can see that the <em>while</em> loop will disassemble until it either hits an invalid instruction, or end of the input buffer. Inside the loop, we would do usual binary analysis on the resulted instruction.</p>

<ul>
<li>On <em>line 19</em>, we release the cache memory allocated by <em>cs_malloc</em> with <em>cs_free</em>. Note that we have to tell <em>cs_free</em> to <em>free 1 instruction</em> because this is what <em>cs_malloc</em> did in <em>line 5</em> above: allocated memory for 1 instruction of the type <em>cs_insn</em>. </li>
</ul>

<hr>

<h3>2. Notes.</h3>

<p>Internally, <em>cs<em>disasm</em>iter</em> behaves exactly like <em>cs_disasm</em> if we call <em>cs_disasm</em> with argument <em>count = 1</em>. However, <em>cs<em>disasm</em>iter</em> is faster because it reuses (and also overwrites) the same memory to store disassembled instruction, avoiding all the malloc/realloc in the loop above. So if we just need to do some quick iteration through all the instructions, <em>cs<em>disasm</em>iter</em> should be considered.</p>

<p>On the other hand, <em>cs_disasm</em> is more approriate when we want to disassemble all the instructions (using <em>count = 0</em>), or when we want to save all the disassembled instructions - without overwriting them in the loop - for future reference.</p>

<p>See a full sample of <em>cs<em>disasm</em>iter</em> &amp; <em>cs_malloc</em> in <a href="https://github.com/aquynh/capstone/blob/next/tests/test_iter.c">https://github.com/aquynh/capstone/blob/next/tests/test_iter.c</a></p>

    </div>

    <div class="wrapper-footer">
      <div class="container">
        <footer class="footer">
          
<a href="mailto:capstone.engine@gmail.com"><i class="svg-icon email"></i></a>


<a href="https://github.com/aquynh/capstone"><i class="svg-icon github"></i></a>




<a href="https://www.twitter.com/capstone_engine"><i class="svg-icon twitter"></i></a>



        </footer>
      </div>
    </div>

    

  </body>
</html>
