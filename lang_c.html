<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Capstone - Programming with C language</title><link rel="stylesheet" href="css/style.css" type="text/css" media="all"><link rel="stylesheet" href="css/pygments.css" type="text/css" media="all"><link rel="alternate" href="feed/index.xml" type="application/atom+xml" title="Atom Feed"></head><body><div id="fb-root"></div> <script>!function(e,t,n){var c,o=e.getElementsByTagName(t)[0];e.getElementById(n)||(c=e.createElement(t),c.id=n,c.src="//connect.facebook.net/en_US/all.js#xfbml=1",o.parentNode.insertBefore(c,o))}(document,"script","facebook-jssdk")</script><script>!function(t,e,r){var n,s=t.getElementsByTagName(e)[0],i=/^http:/.test(t.location)?"http":"https";t.getElementById(r)||(n=t.createElement(e),n.id=r,n.src=i+"://platform.twitter.com/widgets.js",s.parentNode.insertBefore(n,s))}(document,"script","twitter-wjs")</script><script>!function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="https://apis.google.com/js/plusone.js";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><div class="page"> <header> <a href="index.html" id="cs_home">Capstone</a> <nav> <a href="index.html">Home</a> <a href="download.html">Download</a> <a href="documentation.html">Docs</a> <a href="showcase.html">Showcase</a> <a href="testimonial.html">Testimonials</a> <a href="donate.html">Donate</a> <a href="contact.html">Contact</a> </nav> </header> <section><h2 id="c-tutorial-for-capstone">C tutorial for Capstone</h2><h3 id="example-code">Example code</h3><p>This short example shows how the Capstone API looks and how easy it is to disassemble binary code with it. There are more APIs than those used here, but these are all we need to get started.</p><div class="highlight"><pre><code class="language-c" data-lang="c"><span class="lineno"> 1</span> <span class="cm">/* test1.c */</span>
<span class="lineno"> 2</span>
<span class="lineno"> 3</span> <span class="cp">#include &lt;stdio.h&gt;</span>
<span class="lineno"> 4</span> <span class="cp">#include &lt;inttypes.h&gt;</span>
<span class="lineno"> 5</span>
<span class="lineno"> 6</span> <span class="cp">#include &lt;capstone/capstone.h&gt;</span>
<span class="lineno"> 7</span>
<span class="lineno"> 8</span> <span class="cp">#define CODE "\x55\x48\x8b\x05\xb8\x13\x00\x00"</span>
<span class="lineno"> 9</span>
<span class="lineno">10</span> <span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="lineno">11</span> <span class="p">{</span>
<span class="lineno">12</span> 	<span class="n">csh</span> <span class="n">handle</span><span class="p">;</span>
<span class="lineno">13</span> 	<span class="n">cs_insn</span> <span class="o">*</span><span class="n">insn</span><span class="p">;</span>
<span class="lineno">14</span> 	<span class="kt">size_t</span> <span class="n">count</span><span class="p">;</span>
<span class="lineno">15</span>
<span class="lineno">16</span> 	<span class="k">if</span> <span class="p">(</span><span class="n">cs_open</span><span class="p">(</span><span class="n">CS_ARCH_X86</span><span class="p">,</span> <span class="n">CS_MODE_64</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">handle</span><span class="p">)</span> <span class="o">!=</span> <span class="n">CS_ERR_OK</span><span class="p">)</span>
<span class="lineno">17</span> 		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="lineno">18</span> 	<span class="n">count</span> <span class="o">=</span> <span class="n">cs_disasm</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">CODE</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">CODE</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mh">0x1000</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">insn</span><span class="p">);</span>
<span class="lineno">19</span> 	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="lineno">20</span> 		<span class="kt">size_t</span> <span class="n">j</span><span class="p">;</span>
<span class="lineno">21</span> 		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
<span class="lineno">22</span> 			<span class="n">printf</span><span class="p">(</span><span class="s">"0x%"</span><span class="n">PRIx64</span><span class="s">":</span><span class="se">\t</span><span class="s">%s</span><span class="se">\t\t</span><span class="s">%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">insn</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">address</span><span class="p">,</span> <span class="n">insn</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">mnemonic</span><span class="p">,</span>
<span class="lineno">23</span> 					<span class="n">insn</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">op_str</span><span class="p">);</span>
<span class="lineno">24</span> 		<span class="p">}</span>
<span class="lineno">25</span>
<span class="lineno">26</span> 		<span class="n">cs_free</span><span class="p">(</span><span class="n">insn</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
<span class="lineno">27</span> 	<span class="p">}</span> <span class="k">else</span>
<span class="lineno">28</span> 		<span class="n">printf</span><span class="p">(</span><span class="s">"ERROR: Failed to disassemble given code!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="lineno">29</span>
<span class="lineno">30</span> 	<span class="n">cs_close</span><span class="p">(</span><span class="o">&amp;</span><span class="n">handle</span><span class="p">);</span>
<span class="lineno">31</span>
<span class="lineno">32</span>     <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="lineno">33</span> <span class="p">}</span></code></pre></div><p><br/> To compile this file, we need a Makefile like below.</p><div class="highlight"><pre><code class="language-makefile" data-lang="makefile"><span class="c"># capstone library name (without prefix 'lib' and suffix '.so')</span>
<span class="nv">LIBNAME</span> <span class="o">=</span> capstone

<span class="nf">test1</span><span class="o">:</span> <span class="n">test</span>1.<span class="n">o</span>
	<span class="k">${</span><span class="nv">CC</span><span class="k">}</span> <span class="nv">$&lt;</span> -O3 -Wall -l<span class="k">$(</span>LIBNAME<span class="k">)</span> -o <span class="nv">$@</span>

<span class="nf">%.o</span><span class="o">:</span> %.<span class="n">c</span>
	<span class="k">${</span><span class="nv">CC</span><span class="k">}</span> -c <span class="nv">$&lt;</span> -o <span class="nv">$@</span></code></pre></div><p><br/> Readers can get this sample code in a zip file <a href="/samples/test1.tgz">here</a>. Compile and run it as follows.</p><div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>make
cc -c test1.c -o test1.o
cc test1.o -O3 -Wall -lcapstone -o test1

<span class="nv">$ </span>./test1
0x1000:	push		rbp
0x1001:	mov		rax, qword ptr <span class="o">[</span>rip + 0x13b8<span class="o">]</span></code></pre></div><p><br/> The C sample is intuitive, but just in case, readers can find below the explanation for each line of <em>test1.c</em>.</p><ul><li><p>Line 6: Include header file <strong>capstone.h</strong> before we do anything.</p></li><li><p>Line 8: Raw binary code we want to disassemble. The code in this sample is in hex mode.</p></li><li><p>Line 12: Declare a handle variable of the type <strong>csh</strong>. This handle will be used at every API of Capstone.</p></li><li><p>Line 13: Declare <em>insn</em>, a pointer variable of the type <strong>cs_insn</strong>, which points to a memory containing all disassembled instructions.</p></li><li><p>Line 16: Initialize Capstone with function <strong>cs_open()</strong>. This API accepts 3 arguments: the hardware architecture, hardware mode and pointer to handle. In this sample, we want to disassemble 64-bit code for X86 architecture. In return, we have the handle updated in variable <em>handle</em>. This API can fail in extreme cases, so our sample verifies the returned result against the error code <em>CS_ERR_OK</em>.</p></li><li><p>Line 18: Disassemble the binary code using the API <strong>cs_disasm()</strong> with the handle we got from the <em>cs_open()</em>. The 2nd &amp; 3rd arguments of <em>cs_disasm()</em> is the binary code to be disassembled and its length. The 4th argument is the address of the first instruction, which is <em>0x1000</em> in this case. If we want to disassemble all the code until either there is no more code, or it encounters a broken instruction, use <em>0</em> as the next argument. In return, this API gives back a dynamically allocated memory in the last argument <em>insn</em>, which can be used to extract out all the disassembled instructions in the next steps. The result of <em>cs_disasm()</em> is the number of instructions successfully disassembled.</p></li><li><p>Line 19: Check if we really have some disassembled instructions at the output of <em>cs_disasm()</em></p></li><li><p>Line 21 ~ 24: Print out all disassembled instructions with their addresses, mnemonics and operands. The structure <strong>cs_insn</strong> exposes all the internal information about the disassembled instruction we are looking at. Some of the most used fields of this structure are presented below.</p></li></ul><table><thead><tr><th>Field</th><th>Meaning</th></tr></thead><tbody><tr><td>id</td><td>Instruction ID of the instruction. This field has data type <em>int</em>.</td></tr><tr><td>address</td><td>Address of the instruction. This field has data type <em>int</em>.</td></tr><tr><td>mnemonic</td><td>Mnemonic of the instruction. This field has data type <em>string</em>.</td></tr><tr><td>op_str</td><td>Operands of the instruction. This field has data type <em>string</em>.</td></tr><tr><td>size</td><td>The size of the instruction, expressed in number of bytes. This field has data type <em>int</em>.</td></tr><tr><td>bytes</td><td>The byte sequence of the instruction. This field has data type <em>array of bytes</em>, with <em>@size</em> above is the array length.</td></tr></tbody></table><p><br/> - Line 26: Free dynamic memory allocated by <em>cs_disasm()</em> with the API <strong>cs_free()</strong>. The 2nd argument passed to <em>cs_free()</em> is the number of disassembled instructions returned by <em>cs_disasm()</em> in line 18.</p><ul><li>Line 30: Close the handle when we are done with the API <strong>cs_close()</strong>.</li></ul><hr/><h3 id="architectures-and-modes">2. Architectures and modes</h3><p>At the moment, Capstone supports 8 hardware architectures with corresponding hardware modes, as follows.</p><p><br/></p><table><thead><tr><th>Architecture</th><th>Basic mode</th></tr></thead><tbody><tr><td>CS_ARCH_ARM<br/><em>ARM architecture</em></td><td>CS_MODE_ARM: <em>Arm mode</em><br/>CS_MODE_THUMB: <em>Thumb mode</em></td></tr><tr><td>CS_ARCH_ARM64<br/><em>ARMv8/AArch64 architecture</em></td><td>CS_MODE_ARM: <em>default mode</em></td></tr><tr><td>CS_ARCH_MIPS<br/><em>Mips architecture</em></td><td>CS_MODE_MIPS32: <em>Mips32 mode</em><br/>CS_MODE_MIPS64: <em>Mips64 mode</em><br/>CS_MODE_MIPS32R6: <em>Mips32R6 mode</em></td></tr><tr><td>CS_ARCH_PPC<br/><em>PowerPC architecture</em></td><td>CS_MODE_32: <em>32-bit mode</em><br/>CS_MODE_64: <em>64-bit mode</em></td></tr><tr><td>CS_ARCH_SPARC<br/><em>Sparc architecture</em></td><td> </td></tr><tr><td>CS_ARCH_SYSZ<br/><em>SystemZ architecture</em></td><td> </td></tr><tr><td>CS_ARCH_X86<br/><em>X86 architecture</em></td><td>CS_MODE_16: <em>16-bit mode</em><br/>CS_MODE_32: <em>32-bit mode</em><br/>CS_MODE_64: <em>64-bit mode</em></td></tr><tr><td>CS_ARCH_XCORE<br/><em>XCore architecture</em></td><td> </td></tr></tbody></table><p><br/> Besides, depending on cases, there are few more modes to be combined with basic modes above.</p><table><thead><tr><th>Extra mode</th><th>Combined with</th></tr></thead><tbody><tr><td>CS_MODE_LITTLE_ENDIAN<br/><em>Little endian mode</em></td><td>CS_MODE_ARM, CS_MODE_THUMB, CS_MODE_32, CS_MODE_64, CS_MODE_MIPS32, CS_MODE_MIPS64, CS_MODE_MIPS32R6</td></tr><tr><td>CS_MODE_BIG_ENDIAN<br/><em>Big endian mode</em></td><td>CS_MODE_ARM, CS_MODE_THUMB, CS_MODE_32, CS_MODE_64, CS_MODE_MIPS32, CS_MODE_MIPS64, CS_MODE_MIPS32R6</td></tr><tr><td>CS_MODE_MICRO<br/><em>MicroMips mode</em></td><td>CS_MODE_MIPS32, CS_MODE_MIPS64, CS_MODE_MIPS32R6</td></tr><tr><td>CS_MODE_MCLASS<br/><em>MClass mode</em></td><td>CS_MODE_ARM</td></tr><tr><td>CS_MODE_V8<br/><em>ARM V8 mode</em></td><td>CS_MODE_ARM, CS_MODE_THUMB</td></tr><tr><td>CS_MODE_V9<br/><em>Sparc V9 mode</em></td><td>CS_MODE_BIG_ENDIAN</td></tr></tbody></table><p><br/> The way to combine extra modes with basic modes is to use the operand <code>+</code>. For example, the sample below initializes Capstone for Mips64 in <em>little endian</em> mode.</p><div class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">cs_open</span><span class="p">(</span><span class="n">CS_ARCH_MIPS</span><span class="p">,</span> <span class="n">CS_MODE_MIPS64</span> <span class="o">+</span> <span class="n">CS_MODE_LITTLE_ENDIAN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">handle</span><span class="p">);</span></code></pre></div><hr/><h3 id="more-architecture-independent-internal-data-of-the-disassembled-instruction">3. More architecture-independent internal data of the disassembled instruction</h3><p>By default, Capstone do not generate details for disassembled instruction. If we want information such as implicit registers read/written or semantic groups that this instruction belongs to, we need to explicitly turn this option <em>on</em>, like in the sample code below.</p><div class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">csh</span> <span class="n">handle</span><span class="p">;</span>

<span class="n">cs_open</span><span class="p">(</span><span class="n">CS_ARCH_X86</span><span class="p">,</span> <span class="n">CS_MODE_64</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">handle</span><span class="p">);</span>
<span class="n">cs_option</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">CS_OPT_DETAIL</span><span class="p">,</span> <span class="n">CS_OPT_ON</span><span class="p">);</span> <span class="c1">// turn ON detail feature with CS_OPT_ON</span></code></pre></div><p><br/> However, keep in mind that producing details costs more memory, complicates the internal operations and slows down the engine a bit, so only do that if needed. If this is no longer desired, we can always reset the engine back to default state at run-time with similar method.</p><div class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">cs_option</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">CS_OPT_DETAIL</span><span class="p">,</span> <span class="n">CS_OPT_OFF</span><span class="p">);</span>	<span class="c1">// no longer generate details</span></code></pre></div><p><br/> Details produced by Capstone provides access to a lot more internal data of the disassembled instruction than the fields introduced in the last sections. Note that these data are all architecture-independent.</p><p>The sample below shows how to extract out details on implicit registers being read by instructions, as well as all the semantic groups this instruction belongs to in some ARM binary.</p><div class="highlight"><pre><code class="language-c" data-lang="c"><span class="lineno"> 1</span> <span class="n">count</span> <span class="o">=</span> <span class="n">cs_disasm</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">CODE</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">CODE</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mh">0x1000</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">all_insn</span><span class="p">);</span>
<span class="lineno"> 2</span> <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="lineno"> 3</span> 	<span class="kt">size_t</span> <span class="n">j</span><span class="p">;</span>
<span class="lineno"> 4</span> 	<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
<span class="lineno"> 5</span> 	<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
<span class="lineno"> 6</span> 		<span class="n">cs_insn</span> <span class="o">*</span><span class="n">i</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">all_insn</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
<span class="lineno"> 7</span> 		<span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">!=</span> <span class="n">ARM_INS_BL</span> <span class="o">&amp;&amp;</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">!=</span> <span class="n">ARM_INS_CMP</span><span class="p">)</span>
<span class="lineno"> 8</span> 			<span class="k">continue</span><span class="p">;</span>
<span class="lineno"> 9</span> 		<span class="n">printf</span><span class="p">(</span><span class="s">"0x%"</span><span class="n">PRIx64</span><span class="s">":</span><span class="se">\t</span><span class="s">%s</span><span class="se">\t\t</span><span class="s">%s // insn-mnem: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
<span class="lineno">10</span> 				<span class="n">i</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">,</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">mnemonic</span><span class="p">,</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">op_str</span><span class="p">,</span>
<span class="lineno">11</span> 				<span class="n">cs_insn_name</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">));</span>
<span class="lineno">12</span>
<span class="lineno">13</span> 		<span class="n">cs_detail</span> <span class="o">*</span><span class="n">detail</span> <span class="o">=</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">detail</span><span class="p">;</span>
<span class="lineno">14</span> 		<span class="k">if</span> <span class="p">(</span><span class="n">detail</span><span class="o">-&gt;</span><span class="n">regs_read_count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="lineno">15</span> 			<span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\t</span><span class="s">Implicit registers read: "</span><span class="p">);</span>
<span class="lineno">16</span> 			<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">detail</span><span class="o">-&gt;</span><span class="n">regs_read_count</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
<span class="lineno">17</span> 				<span class="n">printf</span><span class="p">(</span><span class="s">"%s "</span><span class="p">,</span> <span class="n">cs_reg_name</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">detail</span><span class="o">-&gt;</span><span class="n">regs_read</span><span class="p">[</span><span class="n">n</span><span class="p">]));</span>
<span class="lineno">18</span> 			<span class="p">}</span>
<span class="lineno">19</span> 			<span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="lineno">20</span> 		<span class="p">}</span>
<span class="lineno">21</span>
<span class="lineno">22</span> 		<span class="k">if</span> <span class="p">(</span><span class="n">detail</span><span class="o">-&gt;</span><span class="n">groups_count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="lineno">23</span> 			<span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\t</span><span class="s">This instruction belongs to groups: "</span><span class="p">);</span>
<span class="lineno">24</span> 			<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">detail</span><span class="o">-&gt;</span><span class="n">groups_count</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
<span class="lineno">25</span> 				<span class="n">printf</span><span class="p">(</span><span class="s">"%u "</span><span class="p">,</span> <span class="n">detail</span><span class="o">-&gt;</span><span class="n">groups</span><span class="p">[</span><span class="n">n</span><span class="p">]);</span>
<span class="lineno">26</span> 			<span class="p">}</span>
<span class="lineno">27</span> 			<span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="lineno">28</span> 		<span class="p">}</span>
<span class="lineno">29</span> 	<span class="p">}</span>
<span class="lineno">30</span> <span class="p">}</span></code></pre></div><p><br/> Readers might already figure out how the code above work, as it is simple enough:</p><ul><li><p>Line 6: type-cast inspected instruction to variable <em>i</em> for simplicity.</p></li><li><p>Line 7: In this example, we only care about some instructions, which is either <em>bl</em> or <em>cmp</em>, and ignore everything else. All the constant numbers can be found in file <strong>arm.h</strong> in the same directory of the header file <em>capstone.h</em>.</p></li><li><p>Line 13: Type-cast detail information (of data type <strong>cs_detail</strong>) to a variable named <em>detail</em> for brevity.</p></li><li><p>Line 14: Check if this instruction <em>implicitly</em> reads any registers. If so, next block prints out all these register names.</p></li><li><p>Line 17: While we can simply print out the register ID (which has data type <em>int</em>), it is more friendly to print out its register name instead. This can be done with the API <strong>cs_reg_name()</strong>, which accepts the register ID as its 2nd argument.</p></li><li><p>Line 22 ~ 26: Check if this instruction belongs to any semantic group. If so, print out all group ID. Similarly, we can find all the group ID in the header file <em>arm.h</em>.</p></li></ul><p><br/> The output of the above sample is like below.</p><div class="highlight"><pre><code class="language-objdump" data-lang="objdump"><span class="x">0x1000:	bl	#0x104c			// insn-name: BL</span>
<span class="x">		Implicit registers read:  pc</span>
<span class="x">		This instruction belongs to groups: 20</span>
<span class="x">0x101c:	cmp	r3, #0			// insn-name: CMP</span>
<span class="x">		This instruction belongs to groups: 20</span></code></pre></div><hr/><h3 id="architecture-dependent-details">4. Architecture-dependent details</h3><p>Structure <em>cs_detail</em> has an union structure enabling access to architectured details in <em>arm</em>, <em>arm64</em>, <em>mips</em>, <em>ppc</em> or <em>x86</em> structures, depending on the current disassembling hardware mode. Refer to corresponding header file <em>arm.h</em>, <em>arm64.h</em>, <em>mips.h</em>, <em>ppc.h</em> &amp; <em>x86.h</em> for further details on what information Capstone can provide.</p><p>The sample below demonstrates how to extract the details of instruction operands of ARM64 code.</p><div class="highlight"><pre><code class="language-c" data-lang="c"><span class="lineno"> 1</span> <span class="c1">// assume "insn"is a pointer variable to structure cs_insn</span>
<span class="lineno"> 2</span> <span class="n">cs_detail</span> <span class="o">*</span><span class="n">detail</span> <span class="o">=</span> <span class="n">insn</span><span class="o">-&gt;</span><span class="n">detail</span><span class="p">;</span>
<span class="lineno"> 3</span> <span class="k">if</span> <span class="p">(</span><span class="n">detail</span><span class="o">-&gt;</span><span class="n">op_count</span><span class="p">)</span>
<span class="lineno"> 4</span>   <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\t</span><span class="s">Number of operands: %u</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">detail</span><span class="o">-&gt;</span><span class="n">arm64</span><span class="p">.</span><span class="n">op_count</span><span class="p">);</span>
<span class="lineno"> 5</span>
<span class="lineno"> 6</span> <span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">detail</span><span class="o">-&gt;</span><span class="n">arm64</span><span class="p">.</span><span class="n">op_count</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
<span class="lineno"> 7</span>   <span class="n">cs_arm64_op</span> <span class="o">*</span><span class="n">op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">detail</span><span class="o">-&gt;</span><span class="n">arm64</span><span class="p">.</span><span class="n">operands</span><span class="p">[</span><span class="n">n</span><span class="p">]);</span>
<span class="lineno"> 8</span>   <span class="k">switch</span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
<span class="lineno"> 9</span>     <span class="k">case</span> <span class="nl">ARM64_OP_REG</span><span class="p">:</span>
<span class="lineno">10</span>       <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\t\t</span><span class="s">operands[%u].type: REG = %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">cs_reg_name</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">reg</span><span class="p">));</span>
<span class="lineno">11</span>       <span class="k">break</span><span class="p">;</span>
<span class="lineno">12</span>     <span class="k">case</span> <span class="nl">ARM64_OP_IMM</span><span class="p">:</span>
<span class="lineno">13</span>       <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\t\t</span><span class="s">operands[%u].type: IMM = 0x%x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">imm</span><span class="p">);</span>
<span class="lineno">14</span>       <span class="k">break</span><span class="p">;</span>
<span class="lineno">15</span>     <span class="k">case</span> <span class="nl">ARM64_OP_FP</span><span class="p">:</span>
<span class="lineno">16</span>       <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\t\t</span><span class="s">operands[%u].type: FP = %f</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">);</span>
<span class="lineno">17</span>       <span class="k">break</span><span class="p">;</span>
<span class="lineno">18</span>     <span class="k">case</span> <span class="nl">ARM64_OP_MEM</span><span class="p">:</span>
<span class="lineno">19</span>       <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\t\t</span><span class="s">operands[%u].type: MEM</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
<span class="lineno">20</span>       <span class="k">if</span> <span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">mem</span><span class="p">.</span><span class="n">base</span> <span class="o">!=</span> <span class="n">ARM64_REG_INVALID</span><span class="p">)</span>
<span class="lineno">21</span>         <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\t\t\t</span><span class="s">operands[%u].mem.base: REG = %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">cs_reg_name</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">mem</span><span class="p">.</span><span class="n">base</span><span class="p">));</span>
<span class="lineno">22</span>       <span class="k">if</span> <span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">mem</span><span class="p">.</span><span class="n">index</span> <span class="o">!=</span> <span class="n">ARM64_REG_INVALID</span><span class="p">)</span>
<span class="lineno">23</span>         <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\t\t\t</span><span class="s">operands[%u].mem.index: REG = %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">cs_reg_name</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">mem</span><span class="p">.</span><span class="n">index</span><span class="p">));</span>
<span class="lineno">24</span>       <span class="k">if</span> <span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">mem</span><span class="p">.</span><span class="n">disp</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
<span class="lineno">25</span>         <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\t\t\t</span><span class="s">operands[%u].mem.disp: 0x%x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">mem</span><span class="p">.</span><span class="n">disp</span><span class="p">);</span>
<span class="lineno">26</span>       <span class="k">break</span><span class="p">;</span>
<span class="lineno">27</span>     <span class="k">case</span> <span class="nl">ARM64_OP_CIMM</span><span class="p">:</span>
<span class="lineno">28</span>       <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\t\t</span><span class="s">operands[%u].type: C-IMM = %u</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">imm</span><span class="p">);</span>
<span class="lineno">29</span>       <span class="k">break</span><span class="p">;</span>
<span class="lineno">30</span>   <span class="p">}</span>
<span class="lineno">31</span>
<span class="lineno">32</span>   <span class="k">if</span> <span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">shift</span><span class="p">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">ARM64_SFT_INVALID</span> <span class="o">&amp;&amp;</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">shift</span><span class="p">.</span><span class="n">value</span><span class="p">)</span>
<span class="lineno">33</span>     <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\t\t\t</span><span class="s">Shift: type = %u, value = %u</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">shift</span><span class="p">.</span><span class="n">type</span><span class="p">,</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">shift</span><span class="p">.</span><span class="n">value</span><span class="p">);</span>
<span class="lineno">34</span>
<span class="lineno">35</span>   <span class="k">if</span> <span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">ext</span> <span class="o">!=</span> <span class="n">ARM64_EXT_INVALID</span><span class="p">)</span>
<span class="lineno">36</span>     <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\t\t\t</span><span class="s">Ext: %u</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">ext</span><span class="p">);</span>
<span class="lineno">37</span> <span class="p">}</span>
<span class="lineno">38</span>
<span class="lineno">39</span> <span class="k">if</span> <span class="p">(</span><span class="n">detail</span><span class="o">-&gt;</span><span class="n">arm64</span><span class="p">.</span><span class="n">cc</span> <span class="o">!=</span> <span class="n">ARM64_CC_INVALID</span><span class="p">)</span>
<span class="lineno">40</span>   <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\t</span><span class="s">Code condition: %u</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">detail</span><span class="o">-&gt;</span><span class="n">arm64</span><span class="p">.</span><span class="n">cc</span><span class="p">);</span>
<span class="lineno">41</span>
<span class="lineno">42</span> <span class="k">if</span> <span class="p">(</span><span class="n">detail</span><span class="o">-&gt;</span><span class="n">arm64</span><span class="p">.</span><span class="n">update_flags</span><span class="p">)</span>
<span class="lineno">43</span>   <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\t</span><span class="s">Update-flags: True</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="lineno">44</span>
<span class="lineno">45</span> <span class="k">if</span> <span class="p">(</span><span class="n">detail</span><span class="o">-&gt;</span><span class="n">arm64</span><span class="p">.</span><span class="n">writeback</span><span class="p">)</span>
<span class="lineno">46</span>   <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\t</span><span class="s">Write-back: True</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span></code></pre></div><p><br/> The code looks a bit complicated, but actually pretty simple:</p><ul><li><p>Line 2: Assume we already have a pointer to cs_insn structure. This line casts the details to a variable named <em>detail</em> for simplicity.</p></li><li><p>Line 3: Check if this instruction has any operands to print out.</p></li><li><p>Line 9 ~ 11: If this operand is register (reflected by type <em>ARM64_OP_REG</em>), then print out its register name with the API <strong>cs_reg_name()</strong>.</p></li><li><p>Line 12 ~ 14: If this operand is immediate (reflected by type <em>ARM64_OP_IMM</em>), then print out its numerical value.</p></li><li><p>Line 15 ~ 17: If this operand is real number (reflected by type <em>ARM64_OP_FP</em>), then print out its numerical value.</p></li><li><p>Line 18 ~ 26: If this operand is memory reference (reflected by type <em>ARM64_OP_MEM</em>), then print out its base/index registers, together with offset value.</p></li><li><p>Line 27 ~ 29: If this operand is of type C-IMM (coprocessor register type, reflected by <em>ARM64_OP_CIMM</em>), then print out its index value.</p></li><li><p>Line 32 ~ 36: If this operand uses shift or extender, print out their value.</p></li><li><p>Line 39 ~ 40: Print out the code condition of this instruction if relevant.</p></li><li><p>Line 42 ~ 43: If this instruction update flags, print out that.</p></li><li><p>Line 45 ~ 46: If this instruction writes back its value afterwards, print out that.</p></li></ul><p><br/> The output of the above sample is like below.</p><div class="highlight"><pre><code class="language-objdump" data-lang="objdump"><span class="x">0x38:	ldr	w1, [sp, #8]</span>
<span class="x">	Number of operands: 2</span>
<span class="x">		operands[0].type: REG = w1</span>
<span class="x">		operands[1].type: MEM</span>
<span class="x">			operands[1].mem.base: REG = sp</span>
<span class="x">			operands[1].mem.disp: 0x8</span>

<span class="x">0x3c:	csneg	x0, x1, x1, eq</span>
<span class="x">	Number of operands: 3</span>
<span class="x">		operands[0].type: REG = x0</span>
<span class="x">		operands[1].type: REG = x1</span>
<span class="x">		operands[2].type: REG = x1</span>
<span class="x">	Code condition: 1</span>

<span class="x">0x40:	add	x0, x1, x2, lsl #2</span>
<span class="x">	Number of operands: 3</span>
<span class="x">		operands[0].type: REG = x0</span>
<span class="x">		operands[1].type: REG = x1</span>
<span class="x">		operands[2].type: REG = x2</span>
<span class="x">			Shift: type = 1, value = 2</span></code></pre></div><hr/><h3 id="run-time-options">5. Run-time options</h3><p>Besides the <em>CS_OPT_DETAIL</em> option previously introduced, Capstone can customize the engine at run-time, allowing us to set the assembly syntax or dynamically change engine’s mode with the same API <em>cs_option()</em>.</p><h4 id="syntax-option">5.1 Syntax option</h4><p>By default, X86 assembly outputs in Intel syntax. To switch to AT&amp;T syntax instead, we can simply set syntax option using the option <strong>CS_OPT_SYNTAX</strong> with <em>cs_option()</em> like below.</p><div class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">csh</span> <span class="n">handle</span><span class="p">;</span>

<span class="n">cs_open</span><span class="p">(</span><span class="n">CS_ARCH_X86</span><span class="p">,</span> <span class="n">CS_MODE_64</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">handle</span><span class="p">);</span>
<span class="n">cs_option</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">CS_OPT_SYNTAX</span><span class="p">,</span> <span class="n">CS_OPT_SYNTAX_ATT</span><span class="p">);</span> <span class="c1">// CS_OPT_SYNTAX_ATT represents AT&amp;T syntax</span></code></pre></div><p><br/> In case we want to return to Intel syntax, we can reset the syntax in the similar way:</p><div class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">cs_option</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">CS_OPT_SYNTAX</span><span class="p">,</span> <span class="n">CS_OPT_SYNTAX_INTEL</span><span class="p">);</span> <span class="c1">// CS_OPT_SYNTAX_INTEL indicates Intel syntax</span></code></pre></div><h4 id="dynamically-change-disassemble-mode-at-run-time">5.2 Dynamically change disassemble mode at run-time</h4><p>From version 2.0, we can dynamically change the engine’s mode with <em>cs_open()</em> at run-time thanks to a new option <strong>CS_OPT_MODE</strong>.</p><p>This is useful for example with Arm, where we might frequently switch between Arm &amp; Thumb modes without having to create a new engine. This also happens with X86, where we might want to switch back and forth between protected-mode &amp; real-mode code.</p><p>Below sample shows how <em>CS_OPT_MODE</em> can be used to switch back and forth between Arm &amp; Thumb modes at run-time.</p><div class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">cs_open</span><span class="p">(</span><span class="n">CS_ARCH_ARM</span><span class="p">,</span> <span class="n">CS_MODE_ARM</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">handle</span><span class="p">);</span>
<span class="c1">// from now on disassemble Arm code ....</span>

<span class="n">cs_option</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">CS_OPT_MODE</span><span class="p">,</span> <span class="n">CS_MODE_THUMB</span><span class="p">);</span> <span class="c1">// dynamically change engine's mode at run-time</span>
<span class="c1">// from now on disassemble Thumb code ....</span>

<span class="n">cs_option</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">CS_OPT_MODE</span><span class="p">,</span> <span class="n">CS_MODE_ARM</span><span class="p">);</span> <span class="c1">// change back to Arm mode again</span>
<span class="c1">// from now on disassemble Arm code again</span></code></pre></div><hr/><h3 id="diet-engine">6. Diet engine</h3><p>From version 2.1, Capstone supports “diet” compilation option to minimize the engine for embedded purpose. The <em>diet</em> engine no longer updates some data fields of the <em>cs_insn</em> struct, so these fields &amp; some related APIs become irrelevant. See <a href="diet.html">this documentation</a> for further information.</p><hr/><h3 id="more-examples">7. More examples</h3><p>This tutorial does not explain all the API of Capstone yet. Please find more advanced examples in source of <em>test_*.c</em> files under directory <a href="https://github.com/aquynh/capstone/tree/master/tests">tests/</a> in the Capstone source code.</p></section> <footer> </footer></div></body></html>